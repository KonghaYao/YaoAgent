# Memory

方案

1. Local Memory
   1. 前端工具存储和召回数据
   2. 不能跨域存储，相当于是网站独立的记忆
2. Server Memory
   - [ ] Mem0 待看

## 记忆原则

### 有效捕获 (Capture)

快速记录：一有想法、任务、重要信息，立即使用 `manage_memory` 记录下来。
统一入口：尽量将所有临时信息汇总到少数几个固定的“收集箱”，避免信息分散。

### 信息组织方式 (Organize)

标签的使用方式

- 分类与标签：将记录下来的信息按照项目、主题、优先级等进行分类和打标签。使用文件夹路径和标签系统，保证信息检索高效。
- 情境化：将任务和信息与特定的情境（如“@电脑前”、“@办公室”、“@与XX开会”）联系起来。
- 优先级排序：使用艾森豪威尔矩阵（重要且紧急、重要不紧急、紧急不重要、不重要不紧急）对任务进行排序。

思维树的使用方式

- 建立关联：将新知识与已有知识联系起来，形成知识网络。思维导图是一个很好的工具。
- Chunking (组块化)：将复杂信息分解成小的、可管理的单元，再将这些单元组合成更大的意义单位。

### 高效提取 (Retrieve) - 确保在需要时能快速找到信息

- 强大的搜索功能：
  - 关键词
  - 标签搜索
  
情境线索：回忆当时记录信息时的情境、情绪、相关的其他信息，有助于提取。
从目录/索引查找：对于结构化的笔记系统（如自己搭建的知识库），通过目录或索引快速定位。

### 外部化与自动化 (Externalize & Automate) - 建立“第二大脑”

日历与提醒：
模板与清单：对于重复性工作流程，创建标准操作流程（SOP）、模板和检查清单。
知识库构建：

## 记忆设计 - 记忆宫殿

- 所有的记忆都基于全文搜索或者是向量搜索

0. 会话记忆 (Session Memory)
   1. 记忆在 messages 数组中的对话记忆
1. 工作记忆 (Working Memory, WM)
   1. 每个片段不超过 255个字
   2. 由 AI 进行编写, 管理
   3. 记忆用户相关的偏好，行为
   4. 需要构建一个索引机制，帮助 AI 能够通过索引直接获取到文件
2. 文档记忆
   1. 由上下文决定，上下文的工具输出均可以从文档记忆中抽取
   2. 网络搜索的数据都存储在文档记忆里面
3. 长时记忆 (Long-Term Memory, LTM)
   - 常识记忆（共享）
     - 所有记忆来自一个稳定的常识库，大部分是静态可用的正确数据
   - 经验记忆（私有）
     - 与工具相关的记忆，与人员相关的记忆

## 记忆体结构

1. 索引-文档结构
   1. 通过构建一个非常小的工作记忆文本
      1. 记录所有的文档数据的 path
   2. 所有的大文件都可以通过索引的 path 进行获取
   3. 索引使用思维导图大纲模式

```ts
interface IndexMemory{
   path: string
   description: string
   meta_tags: string[]
}
```

1. 白板结构
   1. 可以随便
2. ToDo 结构
   1. 通过构建一个 ToDo 文本，规划任务

```ts
interface TodoItem{
   name: string
   description: string
   relative_document: string[]
}
```

# Swarm Writer

方案

1. 找具体的提示词，根据提示词划分交接的数据结构

# Web Search 方案

目标：

1. 集成到 LangGraph MCP 内部，提供完整的解决方案
2. 轻量级的爬虫，简单爬取单个网页的 HTML 内容

方案

- [x] website-to-md 可以获取大部分网页
- [x] searXNG 可以作为网络索引
- [x] ❌ crawlee
- [x] ❌ LangSearch：中文搜索能力很差
